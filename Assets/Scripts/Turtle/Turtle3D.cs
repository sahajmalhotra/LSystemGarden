using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Turtle3D
/// --------
/// Interprets a list of L-system symbols and generates a 3D plant structure.
/// 
/// This class implements a classic "turtle graphics" interpreter:
/// - The turtle has a position and rotation.
/// - It moves forward to draw branches.
/// - It rotates based on symbols (+, -, &, ^).
/// - It saves/restores state using a stack ([ and ]).
/// - It can spawn leaves and color geometry based on age.
/// 
/// The geometry is created using helper methods from LGeom.
/// </summary>
public class Turtle3D : MonoBehaviour
{
    // ================================
    // Inspector Fields
    // ================================

    [Header("Scene")]
    public Transform plantRoot;
    // Parent object under which all generated branches and leaves are placed.
    // This keeps the hierarchy clean and allows easy clearing.

    [Header("Base Materials (assigned in Inspector)")]
    public Material branchMaterial;
    public Material barkMaterial;   // Optional override for branch material
    public Material leafMaterial;

    [Header("Rendering")]
    public float defaultAngleDeg = 25f;
    // Default turning angle if none is provided to Interpret()

    public int maxAgeForColor = 8;
    // Used to normalize age when calculating color gradients.

    [Header("Leaf Shape")]
    public float leafWidth = 0.08f;
    public float leafLength = 0.16f;
    // Base size of leaves before scaling.

    // ================================
    // Internal State
    // ================================

    private Stack<TurtleState> stack = new Stack<TurtleState>();
    // Stack used to store turtle states (position, rotation, etc.)
    // Enables branching structures using [ and ].

    // ============================================================
    // Public API
    // ============================================================

    /// <summary>
    /// Deletes all previously generated plant geometry.
    /// Useful before regenerating a new L-system structure.
    /// </summary>
    public void ClearPlant()
    {
        if (plantRoot == null) return;

        // Destroy children in reverse order to avoid index shifting issues
        for (int i = plantRoot.childCount - 1; i >= 0; i--)
        {
            Destroy(plantRoot.GetChild(i).gameObject);
        }
    }

    /// <summary>
    /// Main interpreter function.
    /// Reads a sequence of L-system symbols and generates geometry.
    /// </summary>
    /// <param name="symbols">List of symbols generated by L-system</param>
    /// <param name="angleDeg">Angle for rotations</param>
    /// <param name="clearFirst">Whether to clear existing plant</param>
    public void Interpret(List<Symbol> symbols, float angleDeg, bool clearFirst = true)
    {
        // --- Validation checks ---
        if (plantRoot == null)
        {
            Debug.LogError("Turtle3D: plantRoot not assigned.");
            return;
        }

        if (branchMaterial == null || leafMaterial == null)
        {
            Debug.LogError("Turtle3D: assign branchMaterial and leafMaterial in Inspector.");
            return;
        }

        if (clearFirst) ClearPlant();
        stack.Clear();

        // Initial turtle state
        Vector3 pos = new Vector3(0f, 0f, 0f);
        Quaternion rot = Quaternion.identity;

        float currentAngle = (angleDeg > 0f) ? angleDeg : defaultAngleDeg;

        // --- Interpret each symbol ---
        for (int i = 0; i < symbols.Count; i++)
        {
            Symbol s = symbols[i];

            switch (s.letter)
            {
                case 'F':
                    // Move forward and draw a branch
                    DrawBranch(ref pos, rot, s.length, s.radius, s.age);
                    break;

                case 'L':
                    // Spawn a leaf at current position
                    DrawLeaf(pos, rot, s.length > 0 ? s.length : 1f, s.age);
                    break;

                case '+': // Yaw left
                    rot = rot * Quaternion.Euler(0f, currentAngle, 0f);
                    break;

                case '-': // Yaw right
                    rot = rot * Quaternion.Euler(0f, -currentAngle, 0f);
                    break;

                case '&': // Pitch down
                    rot = rot * Quaternion.Euler(currentAngle, 0f, 0f);
                    break;

                case '^': // Pitch up
                    rot = rot * Quaternion.Euler(-currentAngle, 0f, 0f);
                    break;

                case '[':
                    // Save current turtle state (for branching)
                    stack.Push(new TurtleState(pos, rot, s.radius, s.age));
                    break;

                case ']':
                    // Restore previously saved state
                    if (stack.Count > 0)
                    {
                        TurtleState st = stack.Pop();
                        pos = st.position;
                        rot = st.rotation;
                    }
                    break;
            }
        }
    }

    // ============================================================
    // Geometry Creation
    // ============================================================

    /// <summary>
    /// Creates a cylindrical branch segment between two points.
    /// Updates turtle position to the end of the branch.
    /// </summary>
    private void DrawBranch(ref Vector3 pos, Quaternion rot, float length, float radius, int age)
    {
        // Prevent zero-sized geometry
        if (length <= 0.001f) length = 0.1f;
        if (radius <= 0.001f) radius = 0.01f;

        // Direction is local up rotated by turtle rotation
        Vector3 dir = rot * Vector3.up;

        Vector3 start = pos;
        Vector3 end = pos + dir * length;

        // Choose bark material if assigned
        Material baseMat = (barkMaterial != null) ? barkMaterial : branchMaterial;

        // Create new material instance so coloring doesn't affect all branches
        Material segMat = new Material(baseMat);
        segMat.color = BarkColorByAge(age);

        // Create cylinder geometry
        GameObject cyl = LGeom.Cylinder(start, end, radius, segMat, "Branch");
        cyl.transform.SetParent(plantRoot, worldPositionStays: true);

        // Update turtle position
        pos = end;

        // Optional leaf spawning on older branches
        if (age >= 3)
        {
            DrawLeaf(pos, rot, 1f, age);
        }
    }

    /// <summary>
    /// Creates a simple polygon leaf using triangle fan triangulation.
    /// </summary>
    private void DrawLeaf(Vector3 pos, Quaternion rot, float sizeMult, int age)
    {
        float w = leafWidth * sizeMult;
        float l = leafLength * sizeMult;

        // Leaf defined in local XZ plane
        List<Vector3> ptsLocal = new List<Vector3>
        {
            new Vector3(0f, 0f, 0f),         
            new Vector3(-w, 0f, l * 0.35f),
            new Vector3(-w * 0.6f, 0f, l * 0.8f),
            new Vector3(0f, 0f, l),          
            new Vector3(w * 0.6f, 0f, l * 0.8f),
            new Vector3(w, 0f, l * 0.35f)
        };

        // Rotate leaf into a pleasing orientation
        Quaternion leafRot = rot * Quaternion.Euler(0f, 0f, 90f);

        List<Vector3> ptsWorld = new List<Vector3>(ptsLocal.Count);
        for (int i = 0; i < ptsLocal.Count; i++)
        {
            ptsWorld.Add(pos + (leafRot * ptsLocal[i]));
        }

        // Create per-leaf material instance
        Material leafMatInstance = new Material(leafMaterial);
        leafMatInstance.color = LeafColorByAge(age);

        GameObject leaf = LGeom.FilledPolygon_Fan(ptsWorld, leafMatInstance, "Leaf");

        if (leaf != null)
        {
            leaf.transform.SetParent(plantRoot, worldPositionStays: true);
        }
    }

    // ============================================================
    // Color Utilities
    // ============================================================

    /// <summary>
    /// Returns bark color interpolated based on age.
    /// Younger branches = darker brown.
    /// Older branches = lighter brown.
    /// </summary>
    private Color BarkColorByAge(int age)
    {
        float t = Mathf.Clamp01((float)age / Mathf.Max(1, maxAgeForColor));

        Color dark = new Color(0.25f, 0.18f, 0.10f);
        Color light = new Color(0.55f, 0.38f, 0.20f);

        return Color.Lerp(dark, light, t);
    }

    /// <summary>
    /// Returns leaf color interpolated based on age.
    /// Young leaves = bright green.
    /// Older leaves = darker green.
    /// </summary>
    private Color LeafColorByAge(int age)
    {
        float t = Mathf.Clamp01((float)age / Mathf.Max(1, maxAgeForColor));

        Color fresh = new Color(0.20f, 0.75f, 0.25f);
        Color old = new Color(0.08f, 0.35f, 0.12f);

        return Color.Lerp(fresh, old, t);
    }
}